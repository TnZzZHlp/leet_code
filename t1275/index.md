---
date: 2025-05-25
title: "1275. 找出井字棋的获胜者"
---

井字棋 是由两个玩家 A 和 B 在 3 x 3 的棋盘上进行的游戏。井字棋游戏的规则如下：

玩家轮流将棋子放在空方格 (' ') 上。
第一个玩家 A 总是用 'X' 作为棋子，而第二个玩家 B 总是用 'O' 作为棋子。
'X' 和 'O' 只能放在空方格中，而不能放在已经被占用的方格上。
只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
如果所有方块都放满棋子（不为空），游戏也会结束。
游戏结束后，棋子无法再进行任何移动。
给你一个数组 moves，其中 moves[i] = [rowi, coli] 表示第 i 次移动在 grid[rowi]\[coli]。如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

你可以假设 moves 都 有效（遵循 井字棋 规则），网格最初是空的，A 将先行动。

示例 1：
输入：moves = \[[0,0],[2,0],[1,1],[2,1],[2,2]]
输出："A"
解释："A" 获胜，他总是先走。

示例 2：
输入：moves = \[[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
输出："B"
解释："B" 获胜。

示例 3：
输入：moves = \[[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
输出："Draw"
解释：由于没有办法再行动，游戏以平局结束。

提示：
1 <= moves.length <= 9
moves[i].length == 2
0 <= moves[i]\[j] <= 2
moves 里没有重复的元素。
moves 遵循井字棋的规则。

### 反思

我的实现比较传统而且不够优雅，下面这种实现更优雅，用统计各个获胜线上的棋子数量这个思路确实好，学到了

```rust
impl Solution {
    pub fn tictactoe(moves: Vec<Vec<i32>>) -> String {
        let length = moves.len();
        let mut count = vec![0, 0, 0, 0, 0, 0, 0, 0];
        for i in (0..length).rev().step_by(2) {
            let row = &moves[i][0];
            let col = &moves[i][1];

            count[*row as usize] += 1;
            count[(*col + 3) as usize] += 1;

            if row == col {
                count[6] += 1;
            }

            if row + col == 2 {
                count[7] += 1;
            }

            if count.iter().any(|v| *v == 3) {
                if length % 2 == 0 {
                    return String::from("B");
                } else {
                    return String::from("A");
                }
            }
        }
        if length < 9 {
            return String::from("Pending");
        } else {
            return String::from("Draw");
        }
    }
}
```

## 算法核心思想

这个算法不需要维护完整的棋盘状态，而是通过**计数器**来追踪每个玩家在各个获胜线上的棋子数量。

## 数据结构设计

```rust
let mut count = vec![0, 0, 0, 0, 0, 0, 0, 0];
```

这个 `count` 数组的8个位置分别代表：

- `count[0-2]`: 第0、1、2行的计数
- `count[3-5]`: 第0、1、2列的计数  
- `count[6]`: 主对角线计数
- `count[7]`: 副对角线计数

## 关键逻辑

### 1. 倒序遍历特定玩家的棋子

```rust
for i in (0..length).rev().step_by(2) {
```

- `(0..length).rev()`: 从最后一步开始倒序
- `.step_by(2)`: 每次跳过2步，这样就只处理一个玩家的棋子

由于井字棋是轮流下棋，倒序每隔2步取一个位置，就能只获取最后下棋玩家的所有棋子位置。

### 2. 更新计数器

```rust
let row = &moves[i][0];
let col = &moves[i][1];

count[*row as usize] += 1;        // 行计数+1
count[(*col + 3) as usize] += 1;  // 列计数+1
```

### 3. 对角线处理

```rust
// 如果在主对角线上 (0,0), (1,1), (2,2)
if *row == *col {
    count[6] += 1;
}

// 如果在副对角线上 (0,2), (1,1), (2,0)  
if *row + *col == 2 {
    count[7] += 1;
}
```

### 4. 获胜检查

```rust
if count.iter().any(|&x| x == 3) {
    return String::from("A");  // 或者 "B"，取决于当前检查的是哪个玩家
}
```

## 算法优势

1. **空间效率**: 只需要8个计数器，而不是完整的3×3棋盘
2. **时间效率**: 每个玩家最多下5步棋，检查获胜只需要O(1)时间
3. **逻辑简洁**: 通过计数直接判断是否有任何一条线达到3个棋子

## 与你的代码对比

你的代码使用传统方法：

- 维护完整棋盘状态
- 每次下棋后检查所有获胜条件
- 需要遍历整个棋盘来判断获胜

而这个优化算法：

- 只追踪关键的获胜线计数
- 利用井字棋的特性（轮流下棋）来分别处理两个玩家
- 更加高效和优雅

这是一个很好的算法优化示例，展示了如何通过数学思维来简化问题！
